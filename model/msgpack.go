// Code generated by @apexlang/codegen. DO NOT EDIT.

package model

import (
	"github.com/wapc/tinygo-msgpack"
	"github.com/wapc/tinygo-msgpack/convert"
)

var _ = convert.Package

type parserParseArgs struct {
	Source string `json:"source" yaml:"source" msgpack:"source"`
}

func (o *parserParseArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "source":
			o.Source, err = decoder.ReadString()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *parserParseArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("source")
	encoder.WriteString(o.Source)

	return nil
}

type resolverResolveArgs struct {
	Location string `json:"location" yaml:"location" msgpack:"location"`
	From     string `json:"from" yaml:"from" msgpack:"from"`
}

func (o *resolverResolveArgs) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "location":
			o.Location, err = decoder.ReadString()
		case "from":
			o.From, err = decoder.ReadString()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *resolverResolveArgs) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(2)
	encoder.WriteString("location")
	encoder.WriteString(o.Location)
	encoder.WriteString("from")
	encoder.WriteString(o.From)

	return nil
}

func (o *ParserResult) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "namespace":
			o.Namespace, err = msgpack.DecodeNillable[Namespace](decoder)
		case "errors":
			listSize, err := decoder.ReadArraySize()
			if err != nil {
				return err
			}
			o.Errors = make([]Error, 0, listSize)
			for listSize > 0 {
				listSize--
				var nonNilItem Error
				err = nonNilItem.Decode(decoder)
				if err != nil {
					return err
				}
				o.Errors = append(o.Errors, nonNilItem)
			}
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *ParserResult) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(2)
	encoder.WriteString("namespace")
	o.Namespace.Encode(encoder)
	encoder.WriteString("errors")
	encoder.WriteArraySize(uint32(len(o.Errors)))
	for _, v := range o.Errors {
		v.Encode(encoder)
	}

	return nil
}

func (o *Error) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "message":
			o.Message, err = decoder.ReadString()
		case "positions":
			listSize, err := decoder.ReadArraySize()
			if err != nil {
				return err
			}
			o.Positions = make([]uint32, 0, listSize)
			for listSize > 0 {
				listSize--
				var nonNilItem uint32
				nonNilItem, err = decoder.ReadUint32()
				if err != nil {
					return err
				}
				o.Positions = append(o.Positions, nonNilItem)
			}
		case "locations":
			listSize, err := decoder.ReadArraySize()
			if err != nil {
				return err
			}
			o.Locations = make([]Location, 0, listSize)
			for listSize > 0 {
				listSize--
				var nonNilItem Location
				err = nonNilItem.Decode(decoder)
				if err != nil {
					return err
				}
				o.Locations = append(o.Locations, nonNilItem)
			}
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *Error) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(3)
	encoder.WriteString("message")
	encoder.WriteString(o.Message)
	encoder.WriteString("positions")
	encoder.WriteArraySize(uint32(len(o.Positions)))
	for _, v := range o.Positions {
		encoder.WriteUint32(v)
	}
	encoder.WriteString("locations")
	encoder.WriteArraySize(uint32(len(o.Locations)))
	for _, v := range o.Locations {
		v.Encode(encoder)
	}

	return nil
}

func (o *Location) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "line":
			o.Line, err = decoder.ReadUint32()
		case "column":
			o.Column, err = decoder.ReadUint32()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *Location) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(2)
	encoder.WriteString("line")
	encoder.WriteUint32(o.Line)
	encoder.WriteString("column")
	encoder.WriteUint32(o.Column)

	return nil
}

func (o *Namespace) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "name":
			o.Name, err = decoder.ReadString()
		case "description":
			o.Description, err = decoder.ReadNillableString()
		case "annotations":
			listSize, err := decoder.ReadArraySize()
			if err != nil {
				return err
			}
			o.Annotations = make([]Annotation, 0, listSize)
			for listSize > 0 {
				listSize--
				var nonNilItem Annotation
				err = nonNilItem.Decode(decoder)
				if err != nil {
					return err
				}
				o.Annotations = append(o.Annotations, nonNilItem)
			}
		case "imports":
			listSize, err := decoder.ReadArraySize()
			if err != nil {
				return err
			}
			o.Imports = make([]Import, 0, listSize)
			for listSize > 0 {
				listSize--
				var nonNilItem Import
				err = nonNilItem.Decode(decoder)
				if err != nil {
					return err
				}
				o.Imports = append(o.Imports, nonNilItem)
			}
		case "directives":
			listSize, err := decoder.ReadArraySize()
			if err != nil {
				return err
			}
			o.Directives = make([]Directive, 0, listSize)
			for listSize > 0 {
				listSize--
				var nonNilItem Directive
				err = nonNilItem.Decode(decoder)
				if err != nil {
					return err
				}
				o.Directives = append(o.Directives, nonNilItem)
			}
		case "aliases":
			listSize, err := decoder.ReadArraySize()
			if err != nil {
				return err
			}
			o.Aliases = make([]Alias, 0, listSize)
			for listSize > 0 {
				listSize--
				var nonNilItem Alias
				err = nonNilItem.Decode(decoder)
				if err != nil {
					return err
				}
				o.Aliases = append(o.Aliases, nonNilItem)
			}
		case "functions":
			listSize, err := decoder.ReadArraySize()
			if err != nil {
				return err
			}
			o.Functions = make([]Operation, 0, listSize)
			for listSize > 0 {
				listSize--
				var nonNilItem Operation
				err = nonNilItem.Decode(decoder)
				if err != nil {
					return err
				}
				o.Functions = append(o.Functions, nonNilItem)
			}
		case "interfaces":
			listSize, err := decoder.ReadArraySize()
			if err != nil {
				return err
			}
			o.Interfaces = make([]Interface, 0, listSize)
			for listSize > 0 {
				listSize--
				var nonNilItem Interface
				err = nonNilItem.Decode(decoder)
				if err != nil {
					return err
				}
				o.Interfaces = append(o.Interfaces, nonNilItem)
			}
		case "types":
			listSize, err := decoder.ReadArraySize()
			if err != nil {
				return err
			}
			o.Types = make([]Type, 0, listSize)
			for listSize > 0 {
				listSize--
				var nonNilItem Type
				err = nonNilItem.Decode(decoder)
				if err != nil {
					return err
				}
				o.Types = append(o.Types, nonNilItem)
			}
		case "unions":
			listSize, err := decoder.ReadArraySize()
			if err != nil {
				return err
			}
			o.Unions = make([]Union, 0, listSize)
			for listSize > 0 {
				listSize--
				var nonNilItem Union
				err = nonNilItem.Decode(decoder)
				if err != nil {
					return err
				}
				o.Unions = append(o.Unions, nonNilItem)
			}
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *Namespace) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(10)
	encoder.WriteString("name")
	encoder.WriteString(o.Name)
	encoder.WriteString("description")
	encoder.WriteNillableString(o.Description)
	encoder.WriteString("annotations")
	encoder.WriteArraySize(uint32(len(o.Annotations)))
	for _, v := range o.Annotations {
		v.Encode(encoder)
	}
	encoder.WriteString("imports")
	encoder.WriteArraySize(uint32(len(o.Imports)))
	for _, v := range o.Imports {
		v.Encode(encoder)
	}
	encoder.WriteString("directives")
	encoder.WriteArraySize(uint32(len(o.Directives)))
	for _, v := range o.Directives {
		v.Encode(encoder)
	}
	encoder.WriteString("aliases")
	encoder.WriteArraySize(uint32(len(o.Aliases)))
	for _, v := range o.Aliases {
		v.Encode(encoder)
	}
	encoder.WriteString("functions")
	encoder.WriteArraySize(uint32(len(o.Functions)))
	for _, v := range o.Functions {
		v.Encode(encoder)
	}
	encoder.WriteString("interfaces")
	encoder.WriteArraySize(uint32(len(o.Interfaces)))
	for _, v := range o.Interfaces {
		v.Encode(encoder)
	}
	encoder.WriteString("types")
	encoder.WriteArraySize(uint32(len(o.Types)))
	for _, v := range o.Types {
		v.Encode(encoder)
	}
	encoder.WriteString("unions")
	encoder.WriteArraySize(uint32(len(o.Unions)))
	for _, v := range o.Unions {
		v.Encode(encoder)
	}

	return nil
}

func (o *Import) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "description":
			o.Description, err = decoder.ReadNillableString()
		case "all":
			o.All, err = decoder.ReadBool()
		case "names":
			listSize, err := decoder.ReadArraySize()
			if err != nil {
				return err
			}
			o.Names = make([]ImportRef, 0, listSize)
			for listSize > 0 {
				listSize--
				var nonNilItem ImportRef
				err = nonNilItem.Decode(decoder)
				if err != nil {
					return err
				}
				o.Names = append(o.Names, nonNilItem)
			}
		case "from":
			o.From, err = decoder.ReadString()
		case "annotations":
			listSize, err := decoder.ReadArraySize()
			if err != nil {
				return err
			}
			o.Annotations = make([]Annotation, 0, listSize)
			for listSize > 0 {
				listSize--
				var nonNilItem Annotation
				err = nonNilItem.Decode(decoder)
				if err != nil {
					return err
				}
				o.Annotations = append(o.Annotations, nonNilItem)
			}
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *Import) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(5)
	encoder.WriteString("description")
	encoder.WriteNillableString(o.Description)
	encoder.WriteString("all")
	encoder.WriteBool(o.All)
	encoder.WriteString("names")
	encoder.WriteArraySize(uint32(len(o.Names)))
	for _, v := range o.Names {
		v.Encode(encoder)
	}
	encoder.WriteString("from")
	encoder.WriteString(o.From)
	encoder.WriteString("annotations")
	encoder.WriteArraySize(uint32(len(o.Annotations)))
	for _, v := range o.Annotations {
		v.Encode(encoder)
	}

	return nil
}

func (o *ImportRef) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "name":
			o.Name, err = decoder.ReadString()
		case "as":
			o.As, err = decoder.ReadNillableString()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *ImportRef) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(2)
	encoder.WriteString("name")
	encoder.WriteString(o.Name)
	encoder.WriteString("as")
	encoder.WriteNillableString(o.As)

	return nil
}

func (o *Type) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "name":
			o.Name, err = decoder.ReadString()
		case "description":
			o.Description, err = decoder.ReadNillableString()
		case "fields":
			listSize, err := decoder.ReadArraySize()
			if err != nil {
				return err
			}
			o.Fields = make([]Field, 0, listSize)
			for listSize > 0 {
				listSize--
				var nonNilItem Field
				err = nonNilItem.Decode(decoder)
				if err != nil {
					return err
				}
				o.Fields = append(o.Fields, nonNilItem)
			}
		case "annotations":
			listSize, err := decoder.ReadArraySize()
			if err != nil {
				return err
			}
			o.Annotations = make([]Annotation, 0, listSize)
			for listSize > 0 {
				listSize--
				var nonNilItem Annotation
				err = nonNilItem.Decode(decoder)
				if err != nil {
					return err
				}
				o.Annotations = append(o.Annotations, nonNilItem)
			}
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *Type) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(4)
	encoder.WriteString("name")
	encoder.WriteString(o.Name)
	encoder.WriteString("description")
	encoder.WriteNillableString(o.Description)
	encoder.WriteString("fields")
	encoder.WriteArraySize(uint32(len(o.Fields)))
	for _, v := range o.Fields {
		v.Encode(encoder)
	}
	encoder.WriteString("annotations")
	encoder.WriteArraySize(uint32(len(o.Annotations)))
	for _, v := range o.Annotations {
		v.Encode(encoder)
	}

	return nil
}

func (o *Interface) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "name":
			o.Name, err = decoder.ReadString()
		case "description":
			o.Description, err = decoder.ReadNillableString()
		case "operations":
			listSize, err := decoder.ReadArraySize()
			if err != nil {
				return err
			}
			o.Operations = make([]Operation, 0, listSize)
			for listSize > 0 {
				listSize--
				var nonNilItem Operation
				err = nonNilItem.Decode(decoder)
				if err != nil {
					return err
				}
				o.Operations = append(o.Operations, nonNilItem)
			}
		case "annotations":
			listSize, err := decoder.ReadArraySize()
			if err != nil {
				return err
			}
			o.Annotations = make([]Annotation, 0, listSize)
			for listSize > 0 {
				listSize--
				var nonNilItem Annotation
				err = nonNilItem.Decode(decoder)
				if err != nil {
					return err
				}
				o.Annotations = append(o.Annotations, nonNilItem)
			}
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *Interface) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(4)
	encoder.WriteString("name")
	encoder.WriteString(o.Name)
	encoder.WriteString("description")
	encoder.WriteNillableString(o.Description)
	encoder.WriteString("operations")
	encoder.WriteArraySize(uint32(len(o.Operations)))
	for _, v := range o.Operations {
		v.Encode(encoder)
	}
	encoder.WriteString("annotations")
	encoder.WriteArraySize(uint32(len(o.Annotations)))
	for _, v := range o.Annotations {
		v.Encode(encoder)
	}

	return nil
}

func (o *Alias) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "name":
			o.Name, err = decoder.ReadString()
		case "description":
			o.Description, err = decoder.ReadNillableString()
		case "type":
			o.Type, err = msgpack.Decode[TypeRef](decoder)
		case "annotations":
			listSize, err := decoder.ReadArraySize()
			if err != nil {
				return err
			}
			o.Annotations = make([]Annotation, 0, listSize)
			for listSize > 0 {
				listSize--
				var nonNilItem Annotation
				err = nonNilItem.Decode(decoder)
				if err != nil {
					return err
				}
				o.Annotations = append(o.Annotations, nonNilItem)
			}
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *Alias) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(4)
	encoder.WriteString("name")
	encoder.WriteString(o.Name)
	encoder.WriteString("description")
	encoder.WriteNillableString(o.Description)
	encoder.WriteString("type")
	o.Type.Encode(encoder)
	encoder.WriteString("annotations")
	encoder.WriteArraySize(uint32(len(o.Annotations)))
	for _, v := range o.Annotations {
		v.Encode(encoder)
	}

	return nil
}

func (o *Operation) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "name":
			o.Name, err = decoder.ReadString()
		case "description":
			o.Description, err = decoder.ReadNillableString()
		case "parameters":
			listSize, err := decoder.ReadArraySize()
			if err != nil {
				return err
			}
			o.Parameters = make([]Parameter, 0, listSize)
			for listSize > 0 {
				listSize--
				var nonNilItem Parameter
				err = nonNilItem.Decode(decoder)
				if err != nil {
					return err
				}
				o.Parameters = append(o.Parameters, nonNilItem)
			}
		case "unary":
			o.Unary, err = msgpack.DecodeNillable[Parameter](decoder)
		case "returns":
			o.Returns, err = msgpack.DecodeNillable[TypeRef](decoder)
		case "annotations":
			listSize, err := decoder.ReadArraySize()
			if err != nil {
				return err
			}
			o.Annotations = make([]Annotation, 0, listSize)
			for listSize > 0 {
				listSize--
				var nonNilItem Annotation
				err = nonNilItem.Decode(decoder)
				if err != nil {
					return err
				}
				o.Annotations = append(o.Annotations, nonNilItem)
			}
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *Operation) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(6)
	encoder.WriteString("name")
	encoder.WriteString(o.Name)
	encoder.WriteString("description")
	encoder.WriteNillableString(o.Description)
	encoder.WriteString("parameters")
	encoder.WriteArraySize(uint32(len(o.Parameters)))
	for _, v := range o.Parameters {
		v.Encode(encoder)
	}
	encoder.WriteString("unary")
	o.Unary.Encode(encoder)
	encoder.WriteString("returns")
	if o.Returns == nil {
		encoder.WriteNil()
	} else {
		o.Returns.Encode(encoder)
	}
	encoder.WriteString("annotations")
	encoder.WriteArraySize(uint32(len(o.Annotations)))
	for _, v := range o.Annotations {
		v.Encode(encoder)
	}

	return nil
}

func (o *Parameter) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "name":
			o.Name, err = decoder.ReadString()
		case "description":
			o.Description, err = decoder.ReadNillableString()
		case "type":
			o.Type, err = msgpack.Decode[TypeRef](decoder)
		case "defaultValue":
			o.DefaultValue, err = msgpack.DecodeNillable[Value](decoder)
		case "annotations":
			listSize, err := decoder.ReadArraySize()
			if err != nil {
				return err
			}
			o.Annotations = make([]Annotation, 0, listSize)
			for listSize > 0 {
				listSize--
				var nonNilItem Annotation
				err = nonNilItem.Decode(decoder)
				if err != nil {
					return err
				}
				o.Annotations = append(o.Annotations, nonNilItem)
			}
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *Parameter) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(5)
	encoder.WriteString("name")
	encoder.WriteString(o.Name)
	encoder.WriteString("description")
	encoder.WriteNillableString(o.Description)
	encoder.WriteString("type")
	o.Type.Encode(encoder)
	encoder.WriteString("defaultValue")
	if o.DefaultValue == nil {
		encoder.WriteNil()
	} else {
		o.DefaultValue.Encode(encoder)
	}
	encoder.WriteString("annotations")
	encoder.WriteArraySize(uint32(len(o.Annotations)))
	for _, v := range o.Annotations {
		v.Encode(encoder)
	}

	return nil
}

func (o *Field) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "name":
			o.Name, err = decoder.ReadString()
		case "description":
			o.Description, err = decoder.ReadNillableString()
		case "type":
			o.Type, err = msgpack.Decode[TypeRef](decoder)
		case "defaultValue":
			o.DefaultValue, err = msgpack.DecodeNillable[Value](decoder)
		case "annotations":
			listSize, err := decoder.ReadArraySize()
			if err != nil {
				return err
			}
			o.Annotations = make([]Annotation, 0, listSize)
			for listSize > 0 {
				listSize--
				var nonNilItem Annotation
				err = nonNilItem.Decode(decoder)
				if err != nil {
					return err
				}
				o.Annotations = append(o.Annotations, nonNilItem)
			}
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *Field) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(5)
	encoder.WriteString("name")
	encoder.WriteString(o.Name)
	encoder.WriteString("description")
	encoder.WriteNillableString(o.Description)
	encoder.WriteString("type")
	o.Type.Encode(encoder)
	encoder.WriteString("defaultValue")
	if o.DefaultValue == nil {
		encoder.WriteNil()
	} else {
		o.DefaultValue.Encode(encoder)
	}
	encoder.WriteString("annotations")
	encoder.WriteArraySize(uint32(len(o.Annotations)))
	for _, v := range o.Annotations {
		v.Encode(encoder)
	}

	return nil
}

func (o *Union) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "name":
			o.Name, err = decoder.ReadString()
		case "description":
			o.Description, err = decoder.ReadNillableString()
		case "types":
			listSize, err := decoder.ReadArraySize()
			if err != nil {
				return err
			}
			o.Types = make([]TypeRef, 0, listSize)
			for listSize > 0 {
				listSize--
				var nonNilItem TypeRef
				nonNilItem, err = msgpack.Decode[TypeRef](decoder)
				if err != nil {
					return err
				}
				o.Types = append(o.Types, nonNilItem)
			}
		case "annotations":
			listSize, err := decoder.ReadArraySize()
			if err != nil {
				return err
			}
			o.Annotations = make([]Annotation, 0, listSize)
			for listSize > 0 {
				listSize--
				var nonNilItem Annotation
				err = nonNilItem.Decode(decoder)
				if err != nil {
					return err
				}
				o.Annotations = append(o.Annotations, nonNilItem)
			}
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *Union) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(4)
	encoder.WriteString("name")
	encoder.WriteString(o.Name)
	encoder.WriteString("description")
	encoder.WriteNillableString(o.Description)
	encoder.WriteString("types")
	encoder.WriteArraySize(uint32(len(o.Types)))
	for _, v := range o.Types {
		v.Encode(encoder)
	}
	encoder.WriteString("annotations")
	encoder.WriteArraySize(uint32(len(o.Annotations)))
	for _, v := range o.Annotations {
		v.Encode(encoder)
	}

	return nil
}

func (o *Enum) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "name":
			o.Name, err = decoder.ReadString()
		case "description":
			o.Description, err = decoder.ReadNillableString()
		case "values":
			listSize, err := decoder.ReadArraySize()
			if err != nil {
				return err
			}
			o.Values = make([]EnumValue, 0, listSize)
			for listSize > 0 {
				listSize--
				var nonNilItem EnumValue
				err = nonNilItem.Decode(decoder)
				if err != nil {
					return err
				}
				o.Values = append(o.Values, nonNilItem)
			}
		case "annotations":
			listSize, err := decoder.ReadArraySize()
			if err != nil {
				return err
			}
			o.Annotations = make([]Annotation, 0, listSize)
			for listSize > 0 {
				listSize--
				var nonNilItem Annotation
				err = nonNilItem.Decode(decoder)
				if err != nil {
					return err
				}
				o.Annotations = append(o.Annotations, nonNilItem)
			}
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *Enum) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(4)
	encoder.WriteString("name")
	encoder.WriteString(o.Name)
	encoder.WriteString("description")
	encoder.WriteNillableString(o.Description)
	encoder.WriteString("values")
	encoder.WriteArraySize(uint32(len(o.Values)))
	for _, v := range o.Values {
		v.Encode(encoder)
	}
	encoder.WriteString("annotations")
	encoder.WriteArraySize(uint32(len(o.Annotations)))
	for _, v := range o.Annotations {
		v.Encode(encoder)
	}

	return nil
}

func (o *EnumValue) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "name":
			o.Name, err = decoder.ReadString()
		case "description":
			o.Description, err = decoder.ReadNillableString()
		case "index":
			o.Index, err = decoder.ReadUint64()
		case "display":
			o.Display, err = decoder.ReadNillableString()
		case "annotations":
			listSize, err := decoder.ReadArraySize()
			if err != nil {
				return err
			}
			o.Annotations = make([]Annotation, 0, listSize)
			for listSize > 0 {
				listSize--
				var nonNilItem Annotation
				err = nonNilItem.Decode(decoder)
				if err != nil {
					return err
				}
				o.Annotations = append(o.Annotations, nonNilItem)
			}
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *EnumValue) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(5)
	encoder.WriteString("name")
	encoder.WriteString(o.Name)
	encoder.WriteString("description")
	encoder.WriteNillableString(o.Description)
	encoder.WriteString("index")
	encoder.WriteUint64(o.Index)
	encoder.WriteString("display")
	encoder.WriteNillableString(o.Display)
	encoder.WriteString("annotations")
	encoder.WriteArraySize(uint32(len(o.Annotations)))
	for _, v := range o.Annotations {
		v.Encode(encoder)
	}

	return nil
}

func (o *Directive) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "name":
			o.Name, err = decoder.ReadString()
		case "description":
			o.Description, err = decoder.ReadNillableString()
		case "parameters":
			listSize, err := decoder.ReadArraySize()
			if err != nil {
				return err
			}
			o.Parameters = make([]Parameter, 0, listSize)
			for listSize > 0 {
				listSize--
				var nonNilItem Parameter
				err = nonNilItem.Decode(decoder)
				if err != nil {
					return err
				}
				o.Parameters = append(o.Parameters, nonNilItem)
			}
		case "locations":
			listSize, err := decoder.ReadArraySize()
			if err != nil {
				return err
			}
			o.Locations = make([]DirectiveLocation, 0, listSize)
			for listSize > 0 {
				listSize--
				var nonNilItem DirectiveLocation
				nonNilItem, err = convert.Numeric[DirectiveLocation](decoder.ReadInt32())
				if err != nil {
					return err
				}
				o.Locations = append(o.Locations, nonNilItem)
			}
		case "require":
			listSize, err := decoder.ReadArraySize()
			if err != nil {
				return err
			}
			o.Require = make([]DirectiveRequire, 0, listSize)
			for listSize > 0 {
				listSize--
				var nonNilItem DirectiveRequire
				err = nonNilItem.Decode(decoder)
				if err != nil {
					return err
				}
				o.Require = append(o.Require, nonNilItem)
			}
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *Directive) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(5)
	encoder.WriteString("name")
	encoder.WriteString(o.Name)
	encoder.WriteString("description")
	encoder.WriteNillableString(o.Description)
	encoder.WriteString("parameters")
	encoder.WriteArraySize(uint32(len(o.Parameters)))
	for _, v := range o.Parameters {
		v.Encode(encoder)
	}
	encoder.WriteString("locations")
	encoder.WriteArraySize(uint32(len(o.Locations)))
	for _, v := range o.Locations {
		encoder.WriteInt32(int32(v))
	}
	encoder.WriteString("require")
	encoder.WriteArraySize(uint32(len(o.Require)))
	for _, v := range o.Require {
		v.Encode(encoder)
	}

	return nil
}

func (o *DirectiveRequire) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "directive":
			o.Directive, err = decoder.ReadString()
		case "locations":
			listSize, err := decoder.ReadArraySize()
			if err != nil {
				return err
			}
			o.Locations = make([]DirectiveLocation, 0, listSize)
			for listSize > 0 {
				listSize--
				var nonNilItem DirectiveLocation
				nonNilItem, err = convert.Numeric[DirectiveLocation](decoder.ReadInt32())
				if err != nil {
					return err
				}
				o.Locations = append(o.Locations, nonNilItem)
			}
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *DirectiveRequire) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(2)
	encoder.WriteString("directive")
	encoder.WriteString(o.Directive)
	encoder.WriteString("locations")
	encoder.WriteArraySize(uint32(len(o.Locations)))
	for _, v := range o.Locations {
		encoder.WriteInt32(int32(v))
	}

	return nil
}

func (o *Annotation) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "name":
			o.Name, err = decoder.ReadString()
		case "arguments":
			listSize, err := decoder.ReadArraySize()
			if err != nil {
				return err
			}
			o.Arguments = make([]Argument, 0, listSize)
			for listSize > 0 {
				listSize--
				var nonNilItem Argument
				err = nonNilItem.Decode(decoder)
				if err != nil {
					return err
				}
				o.Arguments = append(o.Arguments, nonNilItem)
			}
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *Annotation) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(2)
	encoder.WriteString("name")
	encoder.WriteString(o.Name)
	encoder.WriteString("arguments")
	encoder.WriteArraySize(uint32(len(o.Arguments)))
	for _, v := range o.Arguments {
		v.Encode(encoder)
	}

	return nil
}

func (o *Argument) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "name":
			o.Name, err = decoder.ReadString()
		case "value":
			o.Value, err = msgpack.Decode[Value](decoder)
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *Argument) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(2)
	encoder.WriteString("name")
	encoder.WriteString(o.Name)
	encoder.WriteString("value")
	o.Value.Encode(encoder)

	return nil
}

func (o *Named) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "kind":
			o.Kind, err = convert.Numeric[Kind](decoder.ReadInt32())
		case "name":
			o.Name, err = decoder.ReadString()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *Named) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(2)
	encoder.WriteString("kind")
	encoder.WriteInt32(int32(o.Kind))
	encoder.WriteString("name")
	encoder.WriteString(o.Name)

	return nil
}

func (o *List) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "type":
			o.Type, err = msgpack.Decode[TypeRef](decoder)
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *List) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("type")
	o.Type.Encode(encoder)

	return nil
}

func (o *Map) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "keyType":
			o.KeyType, err = msgpack.Decode[TypeRef](decoder)
		case "valueType":
			o.ValueType, err = msgpack.Decode[TypeRef](decoder)
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *Map) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(2)
	encoder.WriteString("keyType")
	o.KeyType.Encode(encoder)
	encoder.WriteString("valueType")
	o.ValueType.Encode(encoder)

	return nil
}

func (o *Stream) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "type":
			o.Type, err = msgpack.Decode[TypeRef](decoder)
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *Stream) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("type")
	o.Type.Encode(encoder)

	return nil
}

func (o *Optional) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "type":
			o.Type, err = msgpack.Decode[TypeRef](decoder)
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *Optional) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("type")
	o.Type.Encode(encoder)

	return nil
}

func (o *Reference) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "name":
			o.Name, err = decoder.ReadString()
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *Reference) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("name")
	encoder.WriteString(o.Name)

	return nil
}

func (o *ListValue) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "values":
			listSize, err := decoder.ReadArraySize()
			if err != nil {
				return err
			}
			o.Values = make([]Value, 0, listSize)
			for listSize > 0 {
				listSize--
				var nonNilItem Value
				nonNilItem, err = msgpack.Decode[Value](decoder)
				if err != nil {
					return err
				}
				o.Values = append(o.Values, nonNilItem)
			}
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *ListValue) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("values")
	encoder.WriteArraySize(uint32(len(o.Values)))
	for _, v := range o.Values {
		v.Encode(encoder)
	}

	return nil
}

func (o *ObjectValue) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "fields":
			listSize, err := decoder.ReadArraySize()
			if err != nil {
				return err
			}
			o.Fields = make([]ObjectField, 0, listSize)
			for listSize > 0 {
				listSize--
				var nonNilItem ObjectField
				err = nonNilItem.Decode(decoder)
				if err != nil {
					return err
				}
				o.Fields = append(o.Fields, nonNilItem)
			}
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *ObjectValue) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(1)
	encoder.WriteString("fields")
	encoder.WriteArraySize(uint32(len(o.Fields)))
	for _, v := range o.Fields {
		v.Encode(encoder)
	}

	return nil
}

func (o *ObjectField) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "name":
			o.Name, err = decoder.ReadString()
		case "value":
			o.Value, err = msgpack.Decode[Value](decoder)
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *ObjectField) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	encoder.WriteMapSize(2)
	encoder.WriteString("name")
	encoder.WriteString(o.Name)
	encoder.WriteString("value")
	o.Value.Encode(encoder)

	return nil
}

func (o *TypeRef) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "Scalar":
			o.Scalar, err = convert.NillableNumeric[Scalar](decoder.ReadNillableInt32())
		case "Named":
			o.Named, err = msgpack.DecodeNillable[Named](decoder)
		case "List":
			o.List, err = msgpack.DecodeNillable[List](decoder)
		case "Map":
			o.Map, err = msgpack.DecodeNillable[Map](decoder)
		case "Stream":
			o.Stream, err = msgpack.DecodeNillable[Stream](decoder)
		case "Optional":
			o.Optional, err = msgpack.DecodeNillable[Optional](decoder)
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *TypeRef) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	if o.Scalar != nil {
		encoder.WriteMapSize(1)
		encoder.WriteString("Scalar")
		encoder.WriteNillableInt32((*int32)(o.Scalar))
		return nil
	}
	if o.Named != nil {
		encoder.WriteMapSize(1)
		encoder.WriteString("Named")
		o.Named.Encode(encoder)
		return nil
	}
	if o.List != nil {
		encoder.WriteMapSize(1)
		encoder.WriteString("List")
		o.List.Encode(encoder)
		return nil
	}
	if o.Map != nil {
		encoder.WriteMapSize(1)
		encoder.WriteString("Map")
		o.Map.Encode(encoder)
		return nil
	}
	if o.Stream != nil {
		encoder.WriteMapSize(1)
		encoder.WriteString("Stream")
		o.Stream.Encode(encoder)
		return nil
	}
	if o.Optional != nil {
		encoder.WriteMapSize(1)
		encoder.WriteString("Optional")
		o.Optional.Encode(encoder)
		return nil
	}

	encoder.WriteNil()
	return nil
}

func (o *Value) Decode(decoder msgpack.Reader) error {
	numFields, err := decoder.ReadMapSize()
	if err != nil {
		return err
	}

	for numFields > 0 {
		numFields--
		field, err := decoder.ReadString()
		if err != nil {
			return err
		}
		switch field {
		case "bool":
			o.Bool, err = decoder.ReadNillableBool()
		case "string":
			o.String, err = decoder.ReadNillableString()
		case "i64":
			o.I64, err = decoder.ReadNillableInt64()
		case "f64":
			o.F64, err = decoder.ReadNillableFloat64()
		case "Reference":
			o.Reference, err = msgpack.DecodeNillable[Reference](decoder)
		case "ListValue":
			o.ListValue, err = msgpack.DecodeNillable[ListValue](decoder)
		case "ObjectValue":
			o.ObjectValue, err = msgpack.DecodeNillable[ObjectValue](decoder)
		default:
			err = decoder.Skip()
		}
		if err != nil {
			return err
		}
	}

	return nil
}

func (o *Value) Encode(encoder msgpack.Writer) error {
	if o == nil {
		encoder.WriteNil()
		return nil
	}
	if o.Bool != nil {
		encoder.WriteMapSize(1)
		encoder.WriteString("bool")
		encoder.WriteNillableBool(o.Bool)
		return nil
	}
	if o.String != nil {
		encoder.WriteMapSize(1)
		encoder.WriteString("string")
		encoder.WriteNillableString(o.String)
		return nil
	}
	if o.I64 != nil {
		encoder.WriteMapSize(1)
		encoder.WriteString("i64")
		encoder.WriteNillableInt64(o.I64)
		return nil
	}
	if o.F64 != nil {
		encoder.WriteMapSize(1)
		encoder.WriteString("f64")
		encoder.WriteNillableFloat64(o.F64)
		return nil
	}
	if o.Reference != nil {
		encoder.WriteMapSize(1)
		encoder.WriteString("Reference")
		o.Reference.Encode(encoder)
		return nil
	}
	if o.ListValue != nil {
		encoder.WriteMapSize(1)
		encoder.WriteString("ListValue")
		o.ListValue.Encode(encoder)
		return nil
	}
	if o.ObjectValue != nil {
		encoder.WriteMapSize(1)
		encoder.WriteString("ObjectValue")
		o.ObjectValue.Encode(encoder)
		return nil
	}

	encoder.WriteNil()
	return nil
}
